









zingchart.setModule('gantt');

(function(){
	var CONST_DAY = 86400000; //day in ms

	zingchart.bind(null, 'resize', function(oInfo){
		var oData = zingchart.exec('myChart', 'getdata');
		for (var i =0; i < oData['graphset'].length; i++) {
			oData['graphset'][i] = calcLineWidth(oData['graphset'][i], oInfo.id);
		}
		zingchart.exec('myChart', 'setdata', {
		  data : oData
		});
	});

	// Return oData to feed into building the chart
	zingchart.bind(null, 'dataparse', function(oInfo, oData) {
		for ( var c=0, cLen=oData['graphset'].length;c<cLen;c++ ){
			if ( oData['graphset'][c]['type'] && oData['graphset'][c]['type'] === 'gantt' ) {
				var sGraphType = oData['graphset'][c]['type'];
				var oGraphData = oData['graphset'][c];
				ZC._todash_(oGraphData);

				console.log(oGraphData)
				var oOptions = {
					palette : {
						critical: ['#D31E1E', '#ea7a7a'],
						standard: ['#29A2CC', '#7ecce7']
					}
				};
				if ( oGraphData['options'] ){
					ZC._cp_(oGraphData['options'], oOptions);
				}
				ZC._todash_(oOptions);

				//Setup defaults.
				var oDefaults = {
					type : 'line',
					globals : {
						shadow : false
					},
					plot : {
						marker : {
							visible : false
						}
					},
					plotarea  : {
						margin : 'dynamic'

				    },
				   scaleX : {
						placement : 'opposite',
						step : 'day',
						guide : {
							lineWidth : '1px'
						},
						tick : {
							visible : false
						},
						transform : {
							type : 'date',
							text : '%M-%d'
						},
					   zooming: true
				   },
				   scaleY : {
					   labels : [],
					   offset : 25,
					   mirrored : true,
					   guide : {
						   visible : true,
						   lineWidth : 1,
						   lineStyle : 'solid',
						   rules  :[
							   {
								   rule : '%v % 2 === 0',
								   visible : false
							   }
						   ]
					   },
					   tick : {
						   visible : false
					   }
				   },
					connector : {
						lineWidth : '1px',
						lineColor : '#3c3c3c',
						lineStyle : 'dashed',
						shadow : false,
						tooltip : {
							text : ''
						},
						marker : {
							type : 'triangle',
							borderWidth : 0,
							angle : 90,
							rules : [
								{
									rule : '%i == 5',
									offsetX :-6,
									size : 5,
									visible : true,
									backgroundColor : '#3c3c3c'
								}
							]
						}
					},
					series : [{
					   values : []
				   }]
			   };
			   ZC._cp_(oDefaults, oGraphData);

				//Setup y-axis labels
				var aProjectLabels = [];
				var oProjectMap = {};
				var aProjects = oOptions.values;
				var aSeries = [];
				var scaleIndex = 0;

				//Create project lines
				for ( var i = 0; i < aProjects.length; i++ ){

					//Convert date to unix time
					aProjects[i].start = Date.parse(aProjects[i].start);
					aProjects[i].end = Date.parse(aProjects[i].end);

					//Maintain a logical map of project timelines
					oProjectMap[aProjects[i].id] = {
						start : aProjects[i].start ,
						end : aProjects[i].end,
						index : scaleIndex
					};

					//Normalize progress value to float
					if(typeof aProjects[i].progress === 'string'){
					  aProjects[i].progress = parseFloat(((aProjects[i].progress.slice(0,(aProjects[i].progress).length-1)/100) ).toFixed(2));
					}
					//Create entries per line
					if( aProjects[i].progress === 0 ){
						aSeries.push({
				          values : [[aProjects[i].start, scaleIndex], [aProjects[i].end, scaleIndex]],
				          lineColor : oOptions.palette[aProjects[i].type][1],
				          tooltip : {
				            text : aProjects[i].id + ' : Not started'
				          }
				        })
					}
					else if ( aProjects[i].progress === 1 ){
						aSeries.push({
						  values : [[aProjects[i].start, scaleIndex], [aProjects[i].end, scaleIndex]],
						  lineColor : oOptions.palette[aProjects[i].type][0],
						  tooltip : {
							text : aProjects[i].id + ' : Completed'
						  }
					  	});
					}
					else {
						var progressDate = aProjects[i].start +  (aProjects[i].progress * (aProjects[i].end - aProjects[i].start));
						var progressStart = {
						  values : [[aProjects[i].start, scaleIndex], [progressDate, scaleIndex]],
						  lineColor : oOptions.palette[aProjects[i].type][0],
						  tooltip : {
							text : aProjects[i].id + ' \n Complete : ' + ((aProjects[i].progress).toFixed(2) * 100) + '%' + '\n' + unixToDate(aProjects[i].start) + ' to ' +unixToDate(aProjects[i].end)
						  }
						};
						var progressEnd = {
						  values : [[progressDate, scaleIndex], [aProjects[i].end, scaleIndex]],
						  lineColor : oOptions.palette[aProjects[i].type][1],
						  tooltip : {
							text : aProjects[i].id + ' \n Incomplete : ' + ((1-aProjects[i].progress).toFixed(2) * 100) + '%'+ '\n' + unixToDate(aProjects[i].start) + ' to ' +unixToDate(aProjects[i].end)
						  }
						};
					}
					//Reversed order for tooltip mapping
					aSeries.push(progressEnd);
					aSeries.push(progressStart);

					if(aProjects[i].slack){
					  //Draw a line from the end to the slack date.
					  var slack = {
						values : [ [aProjects[i].end, scaleIndex], [Date.parse(aProjects[i].slack), scaleIndex] ],
						lineColor : '#515151',
						lineWidth : '1px',
						tooltip : {
						  text : 'Slack : ' + aProjects[i].slack
						}
					  };
					  aSeries.push(slack);
					}
					aProjectLabels[scaleIndex -1] = '';
					aProjectLabels[scaleIndex] = aProjects[i].id;

					scaleIndex += 2;
				}

				for ( var i = 0; i < aProjects.length; i++ ){
					var connector = {
					  lineWidth : '1px',
					  lineColor : '#3c3c3c',
					  lineStyle : 'dashed',
					  shadow : false,
					  tooltip : {
						text : ''
					  },
					  marker : {
						type : 'triangle',
						borderWidth : 0,
						angle : 90,
						rules : [
						  {
							rule : '%i == 5',
							offsetX :-6,
							size : 5,
							visible : true,
							backgroundColor : '#3c3c3c'
						  }
						]
					  }
					};
					if(aProjects[i].next){
					  //Build connector line
					  var values = [];
					  var current = oProjectMap[aProjects[i].id];
					  var next = oProjectMap[aProjects[i].next];
					  values.push([current.end, current.index]);
					  values.push([current.end + CONST_DAY, current.index]);
					  connector.tooltip.text = 'From ' + aProjects[i].id + '\n to ' + aProjects[i].next;
					  if(current.end > next.start){
						values.push([current.end + CONST_DAY, current.index + 1]);
						values.push([next.start - (CONST_DAY), current.index + 1]);
						values.push([next.start - (CONST_DAY), next.index]);
						values.push([next.start, next.index]);
					  }
					  else{
						values.push([current.end + CONST_DAY, next.index]);
						values.push([next.start - CONST_DAY + CONST_DAY, next.index]);
						connector.marker.rules[0].rule = '%i == 3';
					  }
					  connector.values = values;
					  aSeries.unshift(connector)
					}
				}
				oGraphData.scaleY.labels = aProjectLabels;
				oGraphData.series = aSeries;

				//Setup startdate
				var iMinVal = Number.MAX_VALUE;
				for( var i = 0 ; i < aProjects.length; i++){
					iMinVal= (aProjects[i].start < iMinVal) ? aProjects[i].start : iMinVal;
				}
				oGraphData.scaleX.minValue = (iMinVal === Number.MAX_VALUE) ? 0 : iMinVal;
				calcLineWidth(oGraphData, oInfo.id);

				

			}
		}
		return oData;
	});

	function createLineMarker(iRange, sText){
		return {
			'type' : 'line',
			'range' : [iRange],
			'line-color' : "#E4E4E4",
			'font-color' : "#777",
			'line-width' : 5,
			'label' : {
				'angle' : 0,
				'text' : sText,
				'font-color' : "#777",
				'font-size' : "15px",
				'offset-x' : -5,
				'offset-y' : 25,
				'vertical-align' : "bottom"
			}
		}
	};

	function calcLineWidth(data, id){
		var chart = document.getElementById(id);
		var width = (chart.clientHeight-50) / data.series.length;
		data.plot.lineWidth = Math.floor(width);
		data.plot.lineWidth = Math.min(data.plot.lineWidth , 50);
		return data;
	}
	function unixToDate(unix){
	   var date = new Date(unix);
		return (date.getMonth()+1) + '/' + date.getDate() + '/' + date.getFullYear();
	}
})();;